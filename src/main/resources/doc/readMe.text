参考文献：
http://blog.csdn.net/zhshulin/article/details/37956105#
QA:
part 1,
项目配置web.xml中welcome-file 注释掉还是默认启动时，index.jsp中的内容，
查看Tomcat conf目录下也存在welcome-file同项目中的配置一样存在index.jsp。注释掉，即可展示出自配置中映射关系。

part 2,
配置spring-dao.xml中
<!-- 引入数据库配置文件 -->
    <context:property-placeholder location="classpath:conf/jdbc.properties" />

    或

     <bean id="propertyConfigurer"
          class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
        <property name="location" value="classpath:conf/jdbc.properties" />
    </bean>
    当配置为第一种情况下，数据库连接池为druid时，若jdbc.properties中数据库连接用户名这样定义时:username=XXX，会报错。应该是Druid框架问题，无法准确识别该username用户名。解决办法：
    重命名username例如：jdbcUsername=XXX即可。
TODO 遗留问题：分析原因。
实现HttpClient
http://blog.csdn.net/qq_35712358/article/details/71426070

CAS 问题单点登录，跨系统访问问题。

Junit Test 问题：
org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'test.redis.RedisTest': Unsatisfied dependency expressed through field 'redisTemplate'; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'org.springframework.data.redis.core.RedisTemplate<java.io.Serializable, java.io.Serializable>' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)}

	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:588)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:88)

猜测原因：
@ContextConfiguration(locations = {"classpath:spring-*.xml"}) 改为 @ContextConfiguration(locations={"classpath:spring-dao.xml","classpath:spring-redis.xml"})即可。
应该是locations 中spring-*.xml问题。

页面展示问题，bootstrap-table-edit.js 引用，尽量写成这种：<script src="...."></script>。而不是这种<script src="..."/>。导致可能引入有问题。


1.如果一个对象的一个方法用了synchronize关键字 假定该方法是A ()分为两种情况:
 <1> A是static的 分为2种情况:
     a.其他方法是synchronized 或没加锁的  那么其他的线程可以访问该对象的其他方法;
     b.其他方法是static  synchronized   不可以访问.
 <2> A是非static的 那么又分三种情况:
     a.其他方法是synchronize 不可访问;
     b.其他方法没有加synchronize 可以访问;
     c.其他方法是 static synchronized 可以访问.

随机Web启动而初始化某些关键数据，至redis缓存中。几种方式：已知5种方式。
 <1>实现InitializingBean接口,同时需要在spring配置文件(xxx.xml)中配置该bean
 <2>若采用XML来配置Bean的话，可以指定属性init-method
 <3>通过注解@PostConstruct来修改初始化方法
 值得注意的是，三者可以同时存在，触发的顺序是先触发@PostConstruct修饰的方法，再触发afterPropertiesSet()，最后触发init-method
 其中@PostConstruct是通过注册一个BeanPostProcessor，在Bean的初始化方法之前调用，而afterPropertiesSet()和init-method都在初始化方法中调用
 <4>当Spring将所有的Bean都初始化完成后，会留给我们一个入口，我们可以实现如下接口ApplicationListener<ContextRefreshedEvent>
 <5>InitServlet继承HttpServlet且在web.xml配置文件中配置
 	<servlet>
 		<servlet-name>InitServlet</servlet-name>
 		<servlet-class>com.zhph.base.servlet.InitServlet</servlet-class>
 		<load-on-startup>1</load-on-startup>
 	</servlet>

Spring多个环境切换问题profile。

