参考文献：
http://blog.csdn.net/zhshulin/article/details/37956105#
QA:
part 1,
项目配置web.xml中welcome-file 注释掉还是默认启动时，index.jsp中的内容，
查看Tomcat conf目录下也存在welcome-file同项目中的配置一样存在index.jsp。注释掉，即可展示出自配置中映射关系。

part 2,
配置spring-dao.xml中
<!-- 引入数据库配置文件 -->
    <context:property-placeholder location="classpath:conf/jdbc.properties" />

    或

     <bean id="propertyConfigurer"
          class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
        <property name="location" value="classpath:conf/jdbc.properties" />
    </bean>
    当配置为第一种情况下，数据库连接池为druid时，若jdbc.properties中数据库连接用户名这样定义时:username=XXX，会报错。应该是Druid框架问题，无法准确识别该username用户名。解决办法：
    重命名username例如：jdbcUsername=XXX即可。
TODO 遗留问题：分析原因。
实现HttpClient
http://blog.csdn.net/qq_35712358/article/details/71426070

CAS 问题单点登录，跨系统访问问题。

Junit Test 问题：
org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'test.redis.RedisTest': Unsatisfied dependency expressed through field 'redisTemplate'; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'org.springframework.data.redis.core.RedisTemplate<java.io.Serializable, java.io.Serializable>' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)}

	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:588)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:88)

猜测原因：
@ContextConfiguration(locations = {"classpath:spring-*.xml"}) 改为 @ContextConfiguration(locations={"classpath:spring-dao.xml","classpath:spring-redis.xml"})即可。
应该是locations 中spring-*.xml问题。

页面展示问题，bootstrap-table-edit.js 引用，尽量写成这种：<script src="...."></script>。而不是这种<script src="..."/>。导致可能引入有问题。


1.如果一个对象的一个方法用了synchronize关键字 假定该方法是A ()分为两种情况:
 <1> A是static的 分为2种情况:
     a.其他方法是synchronized 或没加锁的  那么其他的线程可以访问该对象的其他方法;
     b.其他方法是static  synchronized   不可以访问.
 <2> A是非static的 那么又分三种情况:
     a.其他方法是synchronize 不可访问;
     b.其他方法没有加synchronize 可以访问;
     c.其他方法是 static synchronized 可以访问.
